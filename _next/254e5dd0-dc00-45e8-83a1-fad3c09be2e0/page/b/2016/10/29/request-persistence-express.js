
          window.__NEXT_REGISTER_PAGE('/b/2016/10/29/request-persistence-express', function() {
            var comp = module.exports=webpackJsonp([10],{244:function(e,t,a){e.exports=a(245)},245:function(e,t,a){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0});var l=a(0),o=n(l),s=a(15),r=n(s),i=function(){return o.default.createElement(r.default,{title:"Request-scoped variables in Express",date:"2016-10-29",langs:["en"]},function(){return o.default.createElement("div",null,o.default.createElement("p",null,"One common requirement in web applications is keeping track of the currently logged in user throughout the execution of a request. While this is fairly simple to do in web servers where each request has its own execution environment (be it a thread or a process), Node's single-process single-thread model makes it less straightforward - but it can be achieved with the help of"," ",o.default.createElement("a",{href:"https://github.com/othiym23/node-continuation-local-storage"},o.default.createElement("code",null,"continuation-local-storage")),"."),o.default.createElement("p",null,"Say we have a secure Express application. At some point, a middleware is going to authenticate the user and save it somewhere for future use (again, I'm going to refer to my"," ",o.default.createElement("a",{href:"/2016/10/01/express-jwt"},"earlier post about using JWT with Express")," ","since I had to implement this on the same app). In this case, after authentication is done, we'll have the user available on"," ",o.default.createElement("code",null,"req.user"),". Good so far, but the request object is only available to middlewares and route handlers, and to use it further down the chain we'd need to pass it all the way down through function parameters. In some cases this might make sense, when conceptually each of those functions is related to the user executing them. But here the user was needed to make a permissions check on the opposite boundary of the application - before making a request to an external system, to make sure they had the right permissions to do it."),o.default.createElement("p",null,"So if passing the user as a parameter is not conceptually sound, then how do we get it all the way through to the code making the requests to the external service? Here is where"," ",o.default.createElement("code",null,"continuation-local-storage")," helps. Let's see first how to use it and then try to understand exactly how it's doing it. First, we need to create a namespaces in which to store our data. Even though the namespace will be the same for every request,"," ",o.default.createElement("strong",null,"the values will be scoped for each chain of functions"),"."),o.default.createElement("pre",null,"\nconst { createNamespace } = require('continuation-local-storage')\n\nconst session = createNamespace('request')\n\n// Assuming we have our express app in `app`\napp.use((req, res, next) => {\n  session.run(() => next())\n})\n\n// And once we have authenticated the user\napp.use((req, res, next) => {\n  session.set('currentUser', req.user)\n  next()\n})\n        "),o.default.createElement("p",null,"See that I called the namespace ",o.default.createElement("code",null,"request"),"."," ",o.default.createElement("code",null,"continuation-local-storage")," isn't really specific for a web server environment -"," ",o.default.createElement("strong",null,"it works for any chain of functions calling each other")," ","- so I gave it a name representing exactly what it was being used for in this case."),o.default.createElement("p",null,"Then we have to define a couple of middlewares. For"," ",o.default.createElement("code",null,"continuation-local-storage")," to work,"," ",o.default.createElement("strong",null,"it needs to wrap the chain of function calls on the namespace's"," ",o.default.createElement("code",null,"#run")," method"),". That means that that first middleware has to be defined as early as possible in the middleware chain."," ",o.default.createElement("strong",null,"It's only inside the call stack of that method that values can be set or retrieved from the namespace"),"."),o.default.createElement("p",null,"The second middleware, once the user is available somewhere (",o.default.createElement("code",null,"req.user")," ","in this case), sets it in the namespace. And that's all that's needed for the setup."),o.default.createElement("p",null,"The usage is way simpler since we'll already be inside a"," ",o.default.createElement("code",null,"#run")," chain, so we just have to get a reference to the namespace and fetch the value from it:"),o.default.createElement("pre",null,"\nconst { getNamespace } = require('continuation-local-storage')\n\nfunction getCurrentUser() {\n  return getNamespace('request').get('currentUser')\n}\n        "),o.default.createElement("p",null,"As long as ",o.default.createElement("code",null,"getCurrentUser")," can be traced all the way back to the ",o.default.createElement("code",null,"#run")," method, then everything put on the namespace will be available."),o.default.createElement("h2",null,"How does it work?"),o.default.createElement("p",null,"Personally I was curious on how they achieved this behavior. How do they keep variables across functions calling functions calling functions, many of those asynchronous - going to the OS and back?"),o.default.createElement("p",null,"The answer is"," ",o.default.createElement("a",{href:"https://github.com/othiym23/async-listener"},o.default.createElement("code",null,"async-listener")),". ",o.default.createElement("code",null,"async-listener")," is a package which allows us to set callbacks for the lifecycle of asynchronous operations."," ",o.default.createElement("strong",null,"So when an asynchronous operation is queued, when it fails, and right before or after our callbacks are called, we can add custom behavior"),". ",o.default.createElement("code",null,"continuation-local-storage")," uses it to keep track of each execution context and make the namespace values available again once we're back from the asynchronous operation."),o.default.createElement("p",null,"Then, how does ",o.default.createElement("code",null,"async-listener")," does it? The answer is simple, although the implementation is fairly complex:"," ",o.default.createElement("strong",null,"wrap every asynchronous function in node to be able to provide those callbacks"),". You can"," ",o.default.createElement("a",{href:"https://github.com/othiym23/async-listener/blob/master/index.js"},"take a look at the code to see how they did it on each case"),", with some of the solutions being quite involved (see how they wrap promises!)."),o.default.createElement("h2",null,"Links"),o.default.createElement("ul",null,o.default.createElement("li",null,o.default.createElement("a",{href:"https://github.com/othiym23/node-continuation-local-storage"},o.default.createElement("code",null,"continuation-local-storage"))),o.default.createElement("li",null,o.default.createElement("a",{href:"https://github.com/othiym23/async-listener"},o.default.createElement("code",null,"async-listener")))))})};t.default=i}},[244]);
            return { page: comp.default }
          })
        