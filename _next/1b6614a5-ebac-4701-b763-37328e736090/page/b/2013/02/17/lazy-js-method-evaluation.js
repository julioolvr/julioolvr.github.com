
          window.__NEXT_REGISTER_PAGE('/b/2013/02/17/lazy-js-method-evaluation', function() {
            var comp = module.exports=webpackJsonp([17],{226:function(e,n,o){e.exports=o(227)},227:function(e,n,o){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(n,"__esModule",{value:!0});var t=o(0),l=a(t),d=o(15),u=a(d),r=function(){return l.default.createElement(u.default,{title:"Lazy JS method evaluation",date:"2013-02-17",langs:["es"]},function(){return l.default.createElement("div",null,l.default.createElement("p",null,"El otro día, mirando contra mi voluntad el código de"," ",l.default.createElement("a",{href:"https://github.com/ckeditor/ckeditor-dev"},"CKEditor"),", me encontré con un patrón para evaluación lazy de los métodos de un objeto JS bastante canchero (y probablemente conocido)."),l.default.createElement("p",null,"Por ejemplo, digamos que un método de un objeto tiene una parte excesivamente costosa, representada convenientemente por una función llamada ",l.default.createElement("code",null,"doSomethingExpensive"),"."),l.default.createElement("pre",null,"\nfunction doSomethingExpensive() {\n  console.log('expensive!');\n  return 42;\n}\n\nfunction doSomethingCheap(answer) {\n  return answer + 1;\n}\n\nfunction objeto() {}\n\nobjeto.prototype.metodo = function() {\n  var expensive = doSomethingExpensive();\n  doSomethingCheap(expensive);\n}\n\nvar obj = new objeto();\nobj.metodo(); // logs 'expensive!'\nobj.metodo(); // logs 'expensive!' again\n"),l.default.createElement("p",null,"Bien, con cada llamada a ",l.default.createElement("code",null,"metodo")," se ejecuta"," ",l.default.createElement("code",null,"doSomethingExpensive"),". Si el resultado de esa función varía con cada llamada al método, no hay mucho que hacer. Pero si el resultado puede cachearse, o si es necesario porque el resultado necesita ser compartido entre sucesivas llamadas al método, entonces una primera forma de cambiarlo sería procesarlo cuando se declara el método:"),l.default.createElement("pre",null,"\nobjeto.prototype.metodo = (function() {\n  var expensive = doSomethingExpensive();\n\n  return function() {\n    doSomethingCheap(expensive);\n  };\n})();\n\nvar obj = new objeto(); // logs 'expensive!'\nobj.metodo(); // no loguea nada\nobj.metodo(); // no loguea nada\n"),l.default.createElement("p",null,"La"," ",l.default.createElement("a",{href:"http://benalman.com/news/2010/11/immediately-invoked-function-expression/"},"IIFE")," ","se ejecuta en el momento de declarar el método, evalúa"," ",l.default.createElement("code",null,"doSomethingExpensive"),", almacena el resultado y devuelve una función que usa ese valor almacenado. Esto es un avance, pero presenta la desventaja de que ejecuta"," ",l.default.createElement("code",null,"doSomethingExpensive")," incluso si ",l.default.createElement("code",null,"metodo")," ","nunca se llama. Dependiendo del caso, esto puede ser importante, ya sea que se vayan a inicializar muchos objetos como para retrasar el tiempo de inicio de la aplicación, o porque el resultado de"," ",l.default.createElement("code",null,"doSomethingExpensive")," solamente es significativo en el momento en que se ejecuta ",l.default.createElement("code",null,"metodo"),", no en el momento en el que se declara. En ese caso, la alternativa, que es la que vi en el código de CKEditor (en particular"," ",l.default.createElement("a",{href:"https://github.com/ckeditor/ckeditor-dev/blob/master/core/dom/document.js#L237"},"acá")," ","al momento de escribir esto, el método ",l.default.createElement("code",null,"getWindow")," de"," ",l.default.createElement("code",null,"document"),"), es que el método haga la evaluación, y luego se reemplace a sí mismo por una copia que use el valor ya calculado:"),l.default.createElement("pre",null,"\nobjeto.prototype.metodo = function() {\n  var expensive = doSomethingExpensive();\n  this.metodo = function() {\n    return doSomethingCheap(expensive);\n  };\n  return this.metodo();\n}\n\nvar obj = new objeto(); // no loguea nada\nobj.metodo(); // logs 'expensive!'\nobj.metodo(); // no loguea nada\n"),l.default.createElement("p",null,"Esto combina lo mejor de los dos mundos, no ejecuta"," ",l.default.createElement("code",null,"doSomethingExpensive")," si ",l.default.createElement("code",null,"metodo")," no se ejecuta nunca, y por otro lado si lo hace, lo hace una sola vez y comparte el resultado entre las sucesivas llamadas a"," ",l.default.createElement("code",null,"metodo"),". Aprovechando que el valor de retorno de una asignación es el valor asignado, se puede hacer una versión más corta:"),l.default.createElement("pre",null,"\nobjeto.prototype.metodo = function() {\n  var expensive = doSomethingExpensive();\n  return (this.metodo = function() {\n    return doSomethingCheap(expensive);\n  })();\n}\n"))})};n.default=r}},[226]);
            return { page: comp.default }
          })
        