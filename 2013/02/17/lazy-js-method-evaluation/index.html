<!DOCTYPE html><head><title>Lazy JS method evaluation | Julio</title><meta charset="utf-8"><link rel="shortcut icon" type="image/png" href="/favicon.png"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/css/highlight-ocean.css"><link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Open+Sans|Bree+Serif"><link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Roboto:400,100,300"><link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Raleway:400,100,300"><script async src="//codepen.io/assets/embed/ei.js"></script></head><body><div class="container"><header><a href="/es/"><img class="profile-pic" src="http://www.gravatar.com/avatar/a81ad64d19c864be3c478b761f4b4817?s=300"></a><ul class="bio"><li><a href="/es/">julio olivera</a></li><li>software developer</li><li><a href="http://github.com/julioolvr">github</a>,
<a href="http://www.twitter.com/julioolvr">twitter</a></li></ul></header><main><article class="post"><time datetime="2013-02-17T00:00:00.000Z">2013/02/16</time><h1>Lazy JS method evaluation</h1><div class="tags"><a href="/tags/javascript">#javascript</a></div><p>El otro día, mirando contra mi voluntad el código de <a href="https://github.com/ckeditor/ckeditor-dev">CKEditor</a>, me encontré con un patrón para evaluación lazy de los métodos de un objeto JS bastante canchero (y probablemente conocido).</p>
<p>Por ejemplo, digamos que un método de un objeto tiene una parte excesivamente costosa, representada convenientemente por una función llamada <code>doSomethingExpensive</code>.</p>
<pre class="hljs"><code>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomethingExpensive</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'expensive!'</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomethingCheap</span>(<span class="hljs-params">answer</span>) </span>{
    <span class="hljs-keyword">return</span> answer + <span class="hljs-number">1</span>;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objeto</span>(<span class="hljs-params"></span>) </span>{}

  objeto.prototype.metodo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> expensive = doSomethingExpensive();
    doSomethingCheap(expensive);
  }

  <span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> objeto();
  obj.metodo(); <span class="hljs-comment">// logs 'expensive!'</span>
  obj.metodo(); <span class="hljs-comment">// logs 'expensive!' again</span>
</code></pre>
<p>Bien, con cada llamada a <code>metodo</code> se ejecuta <code>doSomethingExpensive</code>. Si el resultado de esa función varía con cada llamada al método, no hay mucho que hacer. Pero si el resultado puede cachearse, o si es necesario porque el resultado necesita ser compartido entre sucesivas llamadas al método, entonces una primera forma de cambiarlo sería procesarlo cuando se declara el método:</p>
<pre class="hljs"><code>  objeto.prototype.metodo = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> expensive = doSomethingExpensive();

    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      doSomethingCheap(expensive);
    };
  })();

  <span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> objeto(); <span class="hljs-comment">// logs 'expensive!'</span>
  obj.metodo(); <span class="hljs-comment">// no loguea nada</span>
  obj.metodo(); <span class="hljs-comment">// no loguea nada</span>
</code></pre>
<p>La <a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/">IIFE</a> se ejecuta en el momento de declarar el método, evalúa <code>doSomethingExpensive</code>, almacena el resultado y devuelve una función que usa ese valor almacenado. Esto es un avance, pero presenta la desventaja de que ejecuta <code>doSomethingExpensive</code> incluso si <code>metodo</code> nunca se llama. Dependiendo del caso, esto puede ser importante, ya sea que se vayan a inicializar muchos objetos como para retrasar el tiempo de inicio de la aplicación, o porque el resultado de <code>doSomethingExpensive</code> solamente es significativo en el momento en que se ejecuta <code>metodo</code>, no en el momento en el que se declara. En ese caso, la alternativa, que es la que vi en el código de CKEditor (en particular <a href="https://github.com/ckeditor/ckeditor-dev/blob/master/core/dom/document.js#L237">acá</a> al momento de escribir esto, el método <code>getWindow</code> de <code>document</code>), es que el método haga la evaluación, y luego se reemplace a sí mismo por una copia que use el valor ya calculado:</p>
<pre class="hljs"><code>  objeto.prototype.metodo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> expensive = doSomethingExpensive();
    <span class="hljs-keyword">this</span>.metodo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> doSomethingCheap(expensive);
    };
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.metodo();
  }

  <span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> objeto(); <span class="hljs-comment">// no loguea nada</span>
  obj.metodo(); <span class="hljs-comment">// logs 'expensive!'</span>
  obj.metodo(); <span class="hljs-comment">// no loguea nada</span>
</code></pre>
<p>Esto combina lo mejor de los dos mundos, no ejecuta <code>doSomethingExpensive</code> si <code>metodo</code> no se ejecuta nunca, y por otro lado si lo hace, lo hace una sola vez y comparte el resultado entre las sucesivas llamadas a <code>metodo</code>. Aprovechando que el valor de retorno de una asignación es el valor asignado, se puede hacer una versión más corta:</p>
<pre class="hljs"><code>  objeto.prototype.metodo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> expensive = doSomethingExpensive();
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.metodo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> doSomethingCheap(expensive);
    })();
  }
</code></pre>
</article></main></div></body>